import fs from 'fs/promises';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import {
  expandAutogeneratedReferences,
  extractSidebarReferences,
} from './sidebar-reference-extractor';

// Mock fs.readdir
vi.mock('fs/promises', () => {
  const mockReaddir = vi.fn();
  return {
    default: {
      readdir: mockReaddir,
    },
    readdir: mockReaddir,
  };
});

describe('Sidebar Reference Extractor @unit', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  it('should extract document IDs from simple sidebar', async () => {
    const sidebar = {
      docs: [
        {
          type: 'doc',
          id: 'index',
          label: 'Overview',
        },
        {
          type: 'doc',
          id: 'introduction',
          label: 'Introduction',
        },
      ],
    };

    const references = await extractSidebarReferences(sidebar);

    expect(references).toHaveLength(2);
    expect(references[0]).toEqual({ id: 'index', type: 'doc' });
    expect(references[1]).toEqual({ id: 'introduction', type: 'doc' });
  });

  it('should extract document IDs from nested categories', async () => {
    const sidebar = {
      docs: [
        {
          type: 'category' as const,
          label: 'Elements',
          link: {
            type: 'doc' as const,
            id: 'elements/index',
          },
          items: [
            {
              type: 'doc' as const,
              id: 'elements/element1',
              label: 'Element 1',
            },
            {
              type: 'category' as const,
              label: 'Nested',
              link: {
                type: 'doc' as const,
                id: 'elements/nested/index',
              },
              items: [
                {
                  type: 'doc' as const,
                  id: 'elements/nested/item1',
                  label: 'Nested Item 1',
                },
              ],
            },
          ],
        },
      ],
    };

    const references = await extractSidebarReferences(sidebar);

    expect(references).toHaveLength(4);
    expect(references).toContainEqual({ id: 'elements/index', type: 'doc' });
    expect(references).toContainEqual({ id: 'elements/element1', type: 'doc' });
    expect(references).toContainEqual({
      id: 'elements/nested/index',
      type: 'doc',
    });
    expect(references).toContainEqual({
      id: 'elements/nested/item1',
      type: 'doc',
    });
  });

  it('should handle autogenerated directories', async () => {
    const sidebar = {
      docs: [
        {
          type: 'category' as const,
          label: 'Elements',
          items: [
            {
              type: 'autogenerated' as const,
              dirName: 'elements/auto',
            },
          ],
        },
      ],
    };

    const references = await extractSidebarReferences(sidebar);

    expect(references).toHaveLength(1);
    expect(references[0]).toEqual({
      id: 'elements/auto',
      type: 'autogenerated',
      dirName: 'elements/auto',
    });
  });

  it('should expand autogenerated references', async () => {
    // Mock fs.readdir to return some files
    const mockFiles = [
      { name: 'index.md', isFile: () => true, isDirectory: () => false },
      { name: 'file1.md', isFile: () => true, isDirectory: () => false },
      { name: 'file2.mdx', isFile: () => true, isDirectory: () => false },
      { name: 'nested', isFile: () => false, isDirectory: () => true },
    ];

    const mockNestedFiles = [
      { name: 'index.md', isFile: () => true, isDirectory: () => false },
      { name: 'nested1.md', isFile: () => true, isDirectory: () => false },
    ];

    // Setup mock implementation
    (fs.readdir as any).mockImplementation((path: any) => {
      if (path.includes('nested')) {
        return Promise.resolve(mockNestedFiles);
      }
      return Promise.resolve(mockFiles);
    });

    const references = [
      {
        id: 'elements/auto',
        type: 'autogenerated' as const,
        dirName: 'elements/auto',
      },
    ];

    const expanded = await expandAutogeneratedReferences('/site', references);

    // Should include original reference plus expanded files (excluding index files)
    // Original ref + 2 files + nested dir + 1 nested file = 5
    expect(expanded).toHaveLength(5);
    expect(expanded[0]).toEqual(references[0]);
    expect(expanded).toContainEqual({ id: 'elements/auto/file1', type: 'doc' });
    expect(expanded).toContainEqual({ id: 'elements/auto/file2', type: 'doc' });
    expect(expanded).toContainEqual({
      id: 'elements/auto/nested',
      type: 'autogenerated',
      dirName: 'elements/auto/nested',
    });
    expect(expanded).toContainEqual({ id: 'elements/auto/nested/nested1', type: 'doc' });
  });
});
