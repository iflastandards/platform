import { describe, expect, it, vi } from 'vitest';
import * as fileExistenceChecker from './utils/file-existence-checker';
import { FileStructureValidator } from './utils/file-structure-validator';
import * as sidebarReferenceExtractor from './utils/sidebar-reference-extractor';

// Mock the utility modules
vi.mock('./utils/sidebar-reference-extractor', () => ({
  extractSidebarReferencesFromFile: vi.fn(),
  expandAutogeneratedReferences: vi.fn(),
}));

vi.mock('./utils/file-existence-checker', () => ({
  checkFilesExist: vi.fn(),
  generateMissingFilesReport: vi.fn(),
}));

// Mock fs/promises
vi.mock('fs/promises', () => ({
  access: vi.fn().mockResolvedValue(undefined),
  readdir: vi.fn().mockResolvedValue([]),
  mkdir: vi.fn().mockResolvedValue(undefined),
  writeFile: vi.fn().mockResolvedValue(undefined),
}));

describe('Sidebar References Validation Integration', () => {
  it('should validate sidebar references and identify missing files', async () => {
    // Setup
    const validator = new FileStructureValidator('standards');
    const namespace = 'test-standard';

    // Mock the fs/promises.access function to succeed
    const fsPromises = require('fs/promises');
    vi.mocked(fsPromises.access).mockResolvedValue(undefined);

    // Mock the sidebar reference extraction
    const mockReferences = [
      { id: 'index', type: 'doc' },
      { id: 'introduction', type: 'doc' },
      { id: 'elements/element-set-1', type: 'doc' },
      { id: 'vocabularies/vocabulary-1', type: 'doc' },
    ];
    sidebarReferenceExtractor.extractSidebarReferencesFromFile.mockResolvedValue(
      mockReferences,
    );
    sidebarReferenceExtractor.expandAutogeneratedReferences.mockResolvedValue(
      mockReferences,
    );

    // Mock the file existence checker to report missing files
    const missingFiles = [
      {
        id: 'elements/element-set-1',
        expectedPath:
          'standards/test-standard/docs/elements/element-set-1/index.mdx',
        type: 'doc',
      },
      {
        id: 'vocabularies/vocabulary-1',
        expectedPath:
          'standards/test-standard/docs/vocabularies/vocabulary-1.mdx',
        type: 'doc',
      },
    ];
    fileExistenceChecker.checkFilesExist.mockResolvedValue(missingFiles);
    fileExistenceChecker.generateMissingFilesReport.mockReturnValue(
      'Found 2 missing files',
    );

    // Execute
    const result = await validator.validateSidebarReferences(namespace);

    // Verify
    expect(result.isValid).toBe(false);
    expect(result.missingFiles).toEqual(missingFiles);
    expect(result.report).toBe('Found 2 missing files');

    // Verify function calls
    expect(fsPromises.access).toHaveBeenCalledWith(
      'standards/test-standard/sidebars.ts',
    );
    expect(
      sidebarReferenceExtractor.extractSidebarReferencesFromFile,
    ).toHaveBeenCalledWith('standards/test-standard/sidebars.ts');
    expect(
      sidebarReferenceExtractor.expandAutogeneratedReferences,
    ).toHaveBeenCalledWith('standards/test-standard', mockReferences);
    expect(fileExistenceChecker.checkFilesExist).toHaveBeenCalledWith(
      'standards/test-standard',
      mockReferences,
    );
    expect(
      fileExistenceChecker.generateMissingFilesReport,
    ).toHaveBeenCalledWith(missingFiles);
  });

  it('should generate missing files when needed', async () => {
    // Setup
    const validator = new FileStructureValidator('standards');
    const namespace = 'test-standard';

    // Mock the fs/promises functions
    const fsPromises = require('fs/promises');
    vi.mocked(fsPromises.access).mockRejectedValue(new Error('File not found')); // File doesn't exist
    vi.mocked(fsPromises.mkdir).mockResolvedValue(undefined);
    vi.mocked(fsPromises.writeFile).mockResolvedValue(undefined);

    // Missing files to generate
    const missingFiles = [
      {
        id: 'elements/element-set-1',
        expectedPath:
          'standards/test-standard/docs/elements/element-set-1/index.mdx',
        type: 'doc',
      },
      {
        id: 'vocabularies/vocabulary-1',
        expectedPath:
          'standards/test-standard/docs/vocabularies/vocabulary-1.mdx',
        type: 'doc',
      },
    ];

    // Execute
    await validator.generateMissingFiles(namespace, missingFiles);

    // Verify
    expect(fsPromises.mkdir).toHaveBeenCalledWith(
      'standards/test-standard/docs/elements/element-set-1/index.mdx',
      { recursive: true },
    );
    expect(fsPromises.mkdir).toHaveBeenCalledWith(
      'standards/test-standard/docs/vocabularies/vocabulary-1.mdx',
      { recursive: true },
    );

    expect(fsPromises.writeFile).toHaveBeenCalledWith(
      'standards/test-standard/docs/elements/element-set-1/index.mdx',
      expect.stringContaining('# Element-set-1'),
    );
    expect(fsPromises.writeFile).toHaveBeenCalledWith(
      'standards/test-standard/docs/vocabularies/vocabulary-1.mdx',
      expect.stringContaining('# Vocabulary-1'),
    );
  });

  it('should validate all sites in the standards directory', async () => {
    // Setup
    const validator = new FileStructureValidator('standards');

    // Mock fs.readdir to return site directories
    const fsPromises = require('fs/promises');
    vi.mocked(fsPromises.readdir).mockResolvedValue([
      { name: 'site1', isDirectory: () => true },
      { name: 'site2', isDirectory: () => true },
      { name: 'file.txt', isDirectory: () => false }, // Should be ignored
    ]);

    // Mock validateSidebarReferences to return results
    const validateSpy = vi
      .spyOn(validator, 'validateSidebarReferences')
      .mockResolvedValueOnce({
        isValid: true,
        missingFiles: [],
        report: 'All sidebar references have corresponding files. ✅',
      })
      .mockResolvedValueOnce({
        isValid: false,
        missingFiles: [
          {
            id: 'doc1',
            expectedPath: 'standards/site2/docs/doc1.mdx',
            type: 'doc',
          },
        ],
        report: 'Found 1 missing files referenced in sidebar',
      });

    // Execute
    const results = await validator.validateAllSites();

    // Verify
    expect(fsPromises.readdir).toHaveBeenCalledWith('standards', {
      withFileTypes: true,
    });
    expect(validateSpy).toHaveBeenCalledTimes(2);
    expect(validateSpy).toHaveBeenCalledWith('site1');
    expect(validateSpy).toHaveBeenCalledWith('site2');

    expect(results).toEqual({
      site1: {
        isValid: true,
        missingFiles: [],
        report: 'All sidebar references have corresponding files. ✅',
      },
      site2: {
        isValid: false,
        missingFiles: [
          {
            id: 'doc1',
            expectedPath: 'standards/site2/docs/doc1.mdx',
            type: 'doc',
          },
        ],
        report: 'Found 1 missing files referenced in sidebar',
      },
    });

    // Restore the spy
    validateSpy.mockRestore();
  });
});
