import fs from 'fs/promises';
import path from 'path';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import * as fileExistenceChecker from './file-existence-checker';
import { FileStructureValidator } from './file-structure-validator';
import * as sidebarReferenceExtractor from './sidebar-reference-extractor';

// Mock fs/promises module
vi.mock('fs/promises', () => {
  const mockAccess = vi.fn();
  const mockReaddir = vi.fn();
  const mockMkdir = vi.fn();
  const mockWriteFile = vi.fn();
  
  return {
    default: {
      access: mockAccess,
      readdir: mockReaddir,
      mkdir: mockMkdir,
      writeFile: mockWriteFile,
    },
    access: mockAccess,
    readdir: mockReaddir,
    mkdir: mockMkdir,
    writeFile: mockWriteFile,
  };
});

// Mock path module
vi.mock('path', () => ({
  default: {
    join: vi.fn((...args) => args.join('/')),
    dirname: vi.fn((p) => p.split('/').slice(0, -1).join('/')),
    basename: vi.fn((p) => p.split('/').pop()),
  },
  join: vi.fn((...args) => args.join('/')),
  dirname: vi.fn((p) => p.split('/').slice(0, -1).join('/')),
  basename: vi.fn((p) => p.split('/').pop()),
}));

// Mock the utility modules
vi.mock('./file-existence-checker', () => ({
  checkFilesExist: vi.fn(),
  generateMissingFilesReport: vi.fn(),
}));

vi.mock('./sidebar-reference-extractor', () => ({
  extractSidebarReferencesFromFile: vi.fn(),
  expandAutogeneratedReferences: vi.fn(),
}));

describe('FileStructureValidator @unit', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('validateSidebarReferences', () => {
    it('should return valid result when all files exist', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');
      const namespace = 'test';

      // Mock fs.access to succeed (file exists)
      (fs.access as any).mockResolvedValue(undefined);

      // Mock extractSidebarReferencesFromFile to return some references
      (
        sidebarReferenceExtractor.extractSidebarReferencesFromFile as any
      ).mockResolvedValue([
        { id: 'doc1', type: 'doc' },
        { id: 'doc2', type: 'doc' },
      ]);

      // Mock expandAutogeneratedReferences to return the same references
      (
        sidebarReferenceExtractor.expandAutogeneratedReferences as any
      ).mockResolvedValue([
        { id: 'doc1', type: 'doc' },
        { id: 'doc2', type: 'doc' },
      ]);

      // Mock checkFilesExist to return no missing files
      (fileExistenceChecker.checkFilesExist as any).mockResolvedValue([]);

      // Mock generateMissingFilesReport to return success message
      (fileExistenceChecker.generateMissingFilesReport as any).mockReturnValue(
        'All sidebar references have corresponding files. ✅',
      );

      // Execute
      const result = await validator.validateSidebarReferences(namespace);

      // Verify
      expect(result.isValid).toBe(true);
      expect(result.missingFiles).toEqual([]);
      expect(result.report).toBe(
        'All sidebar references have corresponding files. ✅',
      );

      // Verify function calls
      expect(fs.access).toHaveBeenCalledWith('standards/test/sidebars.ts');
      expect(
        sidebarReferenceExtractor.extractSidebarReferencesFromFile,
      ).toHaveBeenCalledWith('standards/test/sidebars.ts');
      expect(
        sidebarReferenceExtractor.expandAutogeneratedReferences,
      ).toHaveBeenCalledWith('standards/test', [
        { id: 'doc1', type: 'doc' },
        { id: 'doc2', type: 'doc' },
      ]);
      expect(fileExistenceChecker.checkFilesExist).toHaveBeenCalledWith(
        'standards/test',
        [
          { id: 'doc1', type: 'doc' },
          { id: 'doc2', type: 'doc' },
        ],
      );
      expect(
        fileExistenceChecker.generateMissingFilesReport,
      ).toHaveBeenCalledWith([]);
    });

    it('should return invalid result when sidebar file does not exist', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');
      const namespace = 'test';

      // Mock fs.access to fail (file doesn't exist)
      (fs.access as any).mockRejectedValue(new Error('File not found'));

      // Execute
      const result = await validator.validateSidebarReferences(namespace);

      // Verify
      expect(result.isValid).toBe(false);
      expect(result.missingFiles).toEqual([]);
      expect(result.report).toBe(
        'Sidebar file not found at standards/test/sidebars.ts',
      );

      // Verify function calls
      expect(fs.access).toHaveBeenCalledWith('standards/test/sidebars.ts');
      expect(
        sidebarReferenceExtractor.extractSidebarReferencesFromFile,
      ).not.toHaveBeenCalled();
    });

    it('should return invalid result when files are missing', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');
      const namespace = 'test';

      // Mock fs.access to succeed (file exists)
      (fs.access as any).mockResolvedValue(undefined);

      // Mock extractSidebarReferencesFromFile to return some references
      (
        sidebarReferenceExtractor.extractSidebarReferencesFromFile as any
      ).mockResolvedValue([
        { id: 'doc1', type: 'doc' },
        { id: 'doc2', type: 'doc' },
      ]);

      // Mock expandAutogeneratedReferences to return the same references
      (
        sidebarReferenceExtractor.expandAutogeneratedReferences as any
      ).mockResolvedValue([
        { id: 'doc1', type: 'doc' },
        { id: 'doc2', type: 'doc' },
      ]);

      // Mock checkFilesExist to return missing files
      const missingFiles = [
        {
          id: 'doc1',
          expectedPath: 'standards/test/docs/doc1.mdx',
          type: 'doc',
        },
      ];
      (fileExistenceChecker.checkFilesExist as any).mockResolvedValue(
        missingFiles,
      );

      // Mock generateMissingFilesReport to return error message
      (fileExistenceChecker.generateMissingFilesReport as any).mockReturnValue(
        'Found 1 missing files referenced in sidebar:\n\n## Missing Document Files\n\n- `doc1` (Expected at: `standards/test/docs/doc1.mdx`)\n',
      );

      // Execute
      const result = await validator.validateSidebarReferences(namespace);

      // Verify
      expect(result.isValid).toBe(false);
      expect(result.missingFiles).toEqual(missingFiles);
      expect(result.report).toContain(
        'Found 1 missing files referenced in sidebar',
      );
    });

    it('should handle errors during validation', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');
      const namespace = 'test';

      // Mock fs.access to succeed (file exists)
      (fs.access as any).mockResolvedValue(undefined);

      // Mock extractSidebarReferencesFromFile to throw an error
      (
        sidebarReferenceExtractor.extractSidebarReferencesFromFile as any
      ).mockRejectedValue(new Error('Failed to extract references'));

      // Execute
      const result = await validator.validateSidebarReferences(namespace);

      // Verify
      expect(result.isValid).toBe(false);
      expect(result.missingFiles).toEqual([]);
      expect(result.report).toBe(
        'Error validating sidebar references: Error: Failed to extract references',
      );
    });
  });

  describe('generateMissingFiles', () => {
    it('should create missing files with placeholder content', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');
      const namespace = 'test';
      const missingFiles = [
        {
          id: 'doc1',
          expectedPath: 'standards/test/docs/doc1.mdx',
          type: 'doc' as const,
        },
        {
          id: 'elements/set1',
          expectedPath: 'standards/test/docs/elements/set1',
          type: 'autogenerated' as const,
        },
      ];

      // Mock fs.access to fail for the first file (doesn't exist) and succeed for the second (exists)
      (fs.access as any)
        .mockRejectedValueOnce(new Error('File not found'))
        .mockResolvedValueOnce(undefined);

      // Mock fs.mkdir to succeed
      (fs.mkdir as any).mockResolvedValue(undefined);

      // Mock fs.writeFile to succeed
      (fs.writeFile as any).mockResolvedValue(undefined);

      // Mock path.basename to return the filename
      (path.basename as any).mockReturnValue('doc1');

      // Execute
      await validator.generateMissingFiles(namespace, missingFiles);

      // Verify - mkdir is called with the directory path, not the file path
      expect(fs.mkdir).toHaveBeenCalledWith('standards/test/docs', {
        recursive: true,
      });
      expect(fs.mkdir).toHaveBeenCalledWith(
        'standards/test/docs/elements',
        { recursive: true },
      );

      // Should only write the first file (doc type), not the autogenerated directory
      expect(fs.writeFile).toHaveBeenCalledTimes(1);
      expect(fs.writeFile).toHaveBeenCalledWith(
        'standards/test/docs/doc1.mdx',
        expect.stringContaining('# Doc1'),
      );
    });

    it('should skip existing files', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');
      const namespace = 'test';
      const missingFiles = [
        {
          id: 'doc1',
          expectedPath: 'standards/test/docs/doc1.mdx',
          type: 'doc' as const,
        },
      ];

      // Mock fs.access to succeed (file exists)
      (fs.access as any).mockResolvedValue(undefined);

      // Mock fs.mkdir to succeed
      (fs.mkdir as any).mockResolvedValue(undefined);

      // Execute
      await validator.generateMissingFiles(namespace, missingFiles);

      // Verify - mkdir is called with the directory path, not the file path
      expect(fs.mkdir).toHaveBeenCalledWith('standards/test/docs', {
        recursive: true,
      });
      expect(fs.writeFile).not.toHaveBeenCalled(); // Should not write the file
    });

    it('should handle errors during file creation', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');
      const namespace = 'test';
      const missingFiles = [
        {
          id: 'doc1',
          expectedPath: 'standards/test/docs/doc1.mdx',
          type: 'doc' as const,
        },
      ];

      // Mock fs.access to fail (file doesn't exist)
      (fs.access as any).mockRejectedValue(new Error('File not found'));

      // Mock fs.mkdir to fail
      (fs.mkdir as any).mockRejectedValue(
        new Error('Failed to create directory'),
      );

      // Mock console.error
      const consoleErrorSpy = vi
        .spyOn(console, 'error')
        .mockImplementation(() => {});

      // Execute
      await validator.generateMissingFiles(namespace, missingFiles);

      // Verify - mkdir is called with the directory path, not the file path
      expect(fs.mkdir).toHaveBeenCalledWith('standards/test/docs', {
        recursive: true,
      });
      expect(fs.writeFile).not.toHaveBeenCalled(); // Should not write the file
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Error creating directory standards/test/docs:',
        expect.any(Error),
      );

      // Restore console.error
      consoleErrorSpy.mockRestore();
    });
  });

  describe('validateAllSites', () => {
    it('should validate all sites in the standards directory', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');

      // Mock fs.readdir to return site directories
      (fs.readdir as any).mockResolvedValue([
        { name: 'site1', isDirectory: () => true },
        { name: 'site2', isDirectory: () => true },
        { name: 'file.txt', isDirectory: () => false }, // Should be ignored
      ]);

      // Mock validateSidebarReferences to return results
      const validateSpy = vi
        .spyOn(validator, 'validateSidebarReferences')
        .mockResolvedValueOnce({
          isValid: true,
          missingFiles: [],
          report: 'All sidebar references have corresponding files. ✅',
        })
        .mockResolvedValueOnce({
          isValid: false,
          missingFiles: [
            {
              id: 'doc1',
              expectedPath: 'standards/site2/docs/doc1.mdx',
              type: 'doc' as const,
            },
          ],
          report: 'Found 1 missing files referenced in sidebar',
        });

      // Execute
      const results = await validator.validateAllSites();

      // Verify
      expect(fs.readdir).toHaveBeenCalledWith('standards', {
        withFileTypes: true,
      });
      expect(validateSpy).toHaveBeenCalledTimes(2);
      expect(validateSpy).toHaveBeenCalledWith('site1');
      expect(validateSpy).toHaveBeenCalledWith('site2');

      expect(results).toEqual({
        site1: {
          isValid: true,
          missingFiles: [],
          report: 'All sidebar references have corresponding files. ✅',
        },
        site2: {
          isValid: false,
          missingFiles: [
            {
              id: 'doc1',
              expectedPath: 'standards/site2/docs/doc1.mdx',
              type: 'doc',
            },
          ],
          report: 'Found 1 missing files referenced in sidebar',
        },
      });

      // Restore the spy
      validateSpy.mockRestore();
    });

    it('should handle errors during validation', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');

      // Mock fs.readdir to throw an error
      (fs.readdir as any).mockRejectedValue(
        new Error('Failed to read directory'),
      );

      // Mock console.error
      const consoleErrorSpy = vi
        .spyOn(console, 'error')
        .mockImplementation(() => {});

      // Execute
      const results = await validator.validateAllSites();

      // Verify
      expect(fs.readdir).toHaveBeenCalledWith('standards', {
        withFileTypes: true,
      });
      expect(results).toEqual({});
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Error validating sites:',
        expect.any(Error),
      );

      // Restore console.error
      consoleErrorSpy.mockRestore();
    });
  });
});
