import fs from 'fs/promises';
import path from 'path';
import { DocReference } from './sidebar-reference-extractor';

/**
 * Interface for missing file report
 */
export interface MissingFileReport {
  id: string;
  expectedPath: string;
  type: 'doc' | 'autogenerated';
}

/**
 * Checks if files exist for all document IDs
 * @param siteDir The site directory path
 * @param references Array of document references
 * @returns Array of missing files
 */
export async function checkFilesExist(
  siteDir: string,
  references: DocReference[],
): Promise<MissingFileReport[]> {
  const missingFiles: MissingFileReport[] = [];

  for (const ref of references) {
    if (ref.type === 'doc') {
      // Check if the document file exists
      const possiblePaths = [
        path.join(siteDir, 'docs', `${ref.id}.md`),
        path.join(siteDir, 'docs', `${ref.id}.mdx`),
        path.join(siteDir, 'docs', ref.id, 'index.md'),
        path.join(siteDir, 'docs', ref.id, 'index.mdx'),
      ];

      let fileExists = false;

      for (const filePath of possiblePaths) {
        try {
          await fs.access(filePath);
          fileExists = true;
          break;
        } catch {
          // File doesn't exist, continue checking other paths
        }
      }

      if (!fileExists) {
        missingFiles.push({
          id: ref.id,
          expectedPath: path.join(siteDir, 'docs', `${ref.id}.mdx`),
          type: 'doc',
        });
      }
    } else if (ref.type === 'autogenerated' && ref.dirName) {
      // Check if the directory exists
      const dirPath = path.join(siteDir, 'docs', ref.dirName);

      try {
        await fs.access(dirPath);
        // Directory exists, check if it has an index file
        const indexPaths = [
          path.join(dirPath, 'index.md'),
          path.join(dirPath, 'index.mdx'),
        ];

        let indexExists = false;

        for (const indexPath of indexPaths) {
          try {
            await fs.access(indexPath);
            indexExists = true;
            break;
          } catch {
            // Index file doesn't exist, continue checking other paths
          }
        }

        if (!indexExists) {
          missingFiles.push({
            id: `${ref.dirName}/index`,
            expectedPath: path.join(siteDir, 'docs', ref.dirName, 'index.mdx'),
            type: 'doc',
          });
        }
      } catch {
        // Directory doesn't exist
        missingFiles.push({
          id: ref.dirName,
          expectedPath: path.join(siteDir, 'docs', ref.dirName),
          type: 'autogenerated',
        });
      }
    }
  }

  return missingFiles;
}

/**
 * Generates a report of missing files
 * @param missingFiles Array of missing files
 * @returns Formatted report string
 */
export function generateMissingFilesReport(
  missingFiles: MissingFileReport[],
): string {
  if (missingFiles.length === 0) {
    return 'All sidebar references have corresponding files. âœ…';
  }

  let report = `Found ${missingFiles.length} missing files referenced in sidebar:\n\n`;

  // Group by type
  const docFiles = missingFiles.filter((file) => file.type === 'doc');
  const autogenFiles = missingFiles.filter(
    (file) => file.type === 'autogenerated',
  );

  if (docFiles.length > 0) {
    report += '## Missing Document Files\n\n';

    for (const file of docFiles) {
      report += `- \`${file.id}\` (Expected at: \`${file.expectedPath}\`)\n`;
    }

    report += '\n';
  }

  if (autogenFiles.length > 0) {
    report += '## Missing Autogenerated Directories\n\n';

    for (const file of autogenFiles) {
      report += `- \`${file.id}\` (Expected at: \`${file.expectedPath}\`)\n`;
    }

    report += '\n';
  }

  report += '### Recommendation\n\n';
  report += 'Create the missing files to ensure the site builds correctly.\n';

  return report;
}
