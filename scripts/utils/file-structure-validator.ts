import fs from 'fs/promises';
import path from 'path';
import {
  checkFilesExist,
  generateMissingFilesReport,
  MissingFileReport,
} from './file-existence-checker';
import {
  expandAutogeneratedReferences,
  extractSidebarReferencesFromFile,
} from './sidebar-reference-extractor';

/**
 * Interface for validation result
 */
export interface ValidationResult {
  isValid: boolean;
  missingFiles: MissingFileReport[];
  report: string;
}

/**
 * File Structure Validator
 * Validates that all sidebar references have corresponding files
 */
export class FileStructureValidator {
  private standardsDir: string;

  constructor(standardsDir: string = 'standards') {
    this.standardsDir = standardsDir;
  }

  /**
   * Validate sidebar references for a namespace
   * @param namespace The namespace to validate
   * @returns Validation result
   */
  async validateSidebarReferences(
    namespace: string,
  ): Promise<ValidationResult> {
    const siteDir = path.join(this.standardsDir, namespace);
    const sidebarPath = path.join(siteDir, 'sidebars.ts');

    try {
      // Check if sidebar file exists
      try {
        await fs.access(sidebarPath);
      } catch {
        return {
          isValid: false,
          missingFiles: [],
          report: `Sidebar file not found at ${sidebarPath}`,
        };
      }

      // Extract references from sidebar
      const references = await extractSidebarReferencesFromFile(sidebarPath);

      // Expand autogenerated references
      const expandedReferences = await expandAutogeneratedReferences(
        siteDir,
        references,
      );

      // Check if files exist
      const missingFiles = await checkFilesExist(siteDir, expandedReferences);

      // Generate report
      const report = generateMissingFilesReport(missingFiles);

      return {
        isValid: missingFiles.length === 0,
        missingFiles,
        report,
      };
    } catch (error) {
      return {
        isValid: false,
        missingFiles: [],
        report: `Error validating sidebar references: ${error}`,
      };
    }
  }

  /**
   * Generate missing files for a namespace
   * @param namespace The namespace to generate files for
   * @param missingFiles Array of missing files
   */
  async generateMissingFiles(
    namespace: string,
    missingFiles: MissingFileReport[],
  ): Promise<void> {
    const siteDir = path.join(this.standardsDir, namespace);

    for (const file of missingFiles) {
      const filePath = file.expectedPath;
      const dirPath = path.dirname(filePath);

      // Create directory if it doesn't exist
      try {
        await fs.mkdir(dirPath, { recursive: true });
      } catch (error) {
        console.error(`Error creating directory ${dirPath}:`, error);
        continue;
      }

      // Skip directories, only create files
      if (file.type === 'autogenerated') {
        continue;
      }

      // Create file with placeholder content
      try {
        // Skip if file already exists
        try {
          await fs.access(filePath);
          console.log(`   ‚è≠Ô∏è  Skipping existing file ${filePath}`);
          continue;
        } catch {
          // File doesn't exist, continue with creation
        }

        // Generate placeholder content
        const fileName = path.basename(file.id);
        const title = fileName
          .split('-')
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');

        const content = `---
title: ${title}
sidebar_position: 1
---

# ${title}

This is a placeholder page for ${file.id}.

*This page is under development.*
`;

        await fs.writeFile(filePath, content);
        console.log(`   üìù Generated missing file ${filePath}`);
      } catch (error) {
        console.error(`Error creating file ${filePath}:`, error);
      }
    }
  }

  /**
   * Validate all sites in batch
   * @returns Object with validation results for each site
   */
  async validateAllSites(): Promise<Record<string, ValidationResult>> {
    const results: Record<string, ValidationResult> = {};

    try {
      // Get all directories in standards folder
      const dirs = await fs.readdir(this.standardsDir, { withFileTypes: true });

      // Filter for directories only
      const sites = dirs
        .filter((dirent) => dirent.isDirectory())
        .map((dirent) => dirent.name);

      // Validate each site
      for (const site of sites) {
        console.log(`Validating ${site}...`);
        results[site] = await this.validateSidebarReferences(site);
      }
    } catch (error) {
      console.error('Error validating sites:', error);
    }

    return results;
  }
}
