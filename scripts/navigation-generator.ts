#!/usr/bin/env tsx

import * as fs from 'fs';
import * as path from 'path';
import { ElementSet, SiteConfiguration, Vocabulary } from './parse-ifla-report';

/**
 * Navigation Generator
 * Generates sidebar navigation configurations for different site types
 */

interface SidebarItem {
  type: 'doc' | 'category' | 'autogenerated';
  id?: string;
  label?: string;
  link?: { type: string; id: string };
  items?: SidebarItem[];
  dirName?: string;
}

interface SidebarConfig {
  docs: SidebarItem[];
}

class NavigationGenerator {
  private standardsDir: string;

  constructor(standardsDir: string = 'standards') {
    this.standardsDir = standardsDir;
  }

  /**
   * Generate navigation for all sites
   */
  async generateAllNavigation(
    siteConfigs: Record<string, SiteConfiguration>,
  ): Promise<void> {
    console.log('üß≠ Starting Navigation Generator...\n');

    for (const [namespace, config] of Object.entries(siteConfigs)) {
      console.log(`Generating navigation for ${namespace}...`);

      try {
        await this.generateSiteNavigation(namespace, config);
        console.log(`‚úÖ Generated ${namespace} navigation`);
      } catch (error) {
        console.error(`‚ùå Failed to generate ${namespace} navigation:`, error);
      }
    }

    console.log('\nüéâ Navigation Generator completed!');
  }

  /**
   * Generate navigation for a single site
   */
  async generateSiteNavigation(
    namespace: string,
    config: SiteConfiguration,
  ): Promise<void> {
    const sitePath = path.join(this.standardsDir, namespace);
    const sidebarPath = path.join(sitePath, 'sidebars.ts');

    // Generate sidebar configuration based on navigation strategy
    const sidebarConfig = this.generateSidebarConfig(config);

    // Generate TypeScript sidebar file
    const sidebarContent = this.generateSidebarFile(sidebarConfig);

    // Write sidebar file
    fs.writeFileSync(sidebarPath, sidebarContent);
    console.log(`   üìù Generated sidebars.ts`);
  }

  /**
   * Generate sidebar configuration based on navigation strategy
   */
  private generateSidebarConfig(config: SiteConfiguration): SidebarConfig {
    switch (config.navigationStrategy) {
      case 'simple':
        return this.generateSimpleNavigation(config);
      case 'categorized':
        return this.generateCategorizedNavigation(config);
      case 'hierarchical':
        return this.generateHierarchicalNavigation(config);
      default:
        return this.generateSimpleNavigation(config);
    }
  }

  /**
   * Generate simple navigation (LRM, MulDiCat)
   */
  private generateSimpleNavigation(config: SiteConfiguration): SidebarConfig {
    const items: SidebarItem[] = [
      {
        type: 'doc',
        id: 'index',
        label: 'Overview',
      },
    ];

    // Add element sets section if present
    if (config.elementSets.length > 0) {
      if (config.elementSets.length === 1) {
        // Single element set - direct link
        items.push({
          type: 'category',
          label: 'Elements',
          link: { type: 'doc', id: 'elements/index' },
          items: [{ type: 'autogenerated', dirName: 'elements' }],
        });
      } else {
        // Multiple element sets
        items.push({
          type: 'category',
          label: 'Element Sets',
          link: { type: 'doc', id: 'elements/index' },
          items: [{ type: 'autogenerated', dirName: 'elements' }],
        });
      }
    }

    // Add vocabularies section if present
    if (config.vocabularies.length > 0) {
      if (config.vocabularies.length === 1) {
        // Single vocabulary - direct link
        items.push({
          type: 'category',
          label: 'Vocabulary',
          link: { type: 'doc', id: 'vocabularies/index' },
          items: [{ type: 'autogenerated', dirName: 'vocabularies' }],
        });
      } else {
        // Multiple vocabularies
        items.push({
          type: 'category',
          label: 'Vocabularies',
          link: { type: 'doc', id: 'vocabularies/index' },
          items: [{ type: 'autogenerated', dirName: 'vocabularies' }],
        });
      }
    }

    // Add documentation section
    items.push({
      type: 'category',
      label: 'Documentation',
      items: [
        { type: 'doc', id: 'introduction' },
        { type: 'doc', id: 'examples' },
        { type: 'doc', id: 'about' },
      ],
    });

    return { docs: items };
  }

  /**
   * Generate categorized navigation (ISBD, FRBR)
   */
  private generateCategorizedNavigation(
    config: SiteConfiguration,
  ): SidebarConfig {
    const items: SidebarItem[] = [
      {
        type: 'doc',
        id: 'index',
        label: 'Overview',
      },
    ];

    // Add element sets section with categories
    if (config.elementSets.length > 0) {
      const elementSetsSection: SidebarItem = {
        type: 'category',
        label: 'Element Sets',
        link: { type: 'doc', id: 'elements/index' },
        items: [],
      };

      // Group element sets by type for FRBR
      if (config.namespace === 'frbr') {
        const frbrModels: SidebarItem[] = [];
        const userTasks: SidebarItem[] = [];

        for (const elementSet of config.elementSets) {
          const item = {
            type: 'doc' as const,
            id: `elements/${elementSet.id}/index`,
          };

          if (elementSet.title.toLowerCase().includes('user task')) {
            userTasks.push(item);
          } else {
            frbrModels.push(item);
          }
        }

        if (frbrModels.length > 0) {
          elementSetsSection.items!.push({
            type: 'category',
            label: 'FRBR Models',
            items: frbrModels,
          });
        }

        if (userTasks.length > 0) {
          elementSetsSection.items!.push({
            type: 'category',
            label: 'User Tasks',
            items: userTasks,
          });
        }
      } else {
        // Standard categorization for other sites
        elementSetsSection.items = config.elementSets.map((es) => ({
          type: 'doc' as const,
          id: `elements/${es.id}/index`,
        }));
      }

      items.push(elementSetsSection);
    }

    // Add vocabularies section with categories
    if (config.vocabularies.length > 0) {
      const vocabulariesSection: SidebarItem = {
        type: 'category',
        label: 'Vocabularies',
        link: { type: 'doc', id: 'vocabularies/index' },
        items: [],
      };

      // Group vocabularies by category if they have categories
      const categories = this.groupVocabulariesByCategory(config.vocabularies);

      if (Object.keys(categories).length > 1) {
        for (const [category, vocabularies] of Object.entries(categories)) {
          vocabulariesSection.items!.push({
            type: 'category',
            label: this.formatCategoryName(category),
            items: vocabularies.map((v) => ({
              type: 'doc' as const,
              id: `vocabularies/${v.id}/index`,
            })),
          });
        }
      } else {
        // No categories, flat list
        vocabulariesSection.items = config.vocabularies.map((v) => ({
          type: 'doc' as const,
          id: `vocabularies/${v.id}/index`,
        }));
      }

      items.push(vocabulariesSection);
    }

    // Add documentation section
    items.push({
      type: 'category',
      label: 'Documentation',
      items: [
        { type: 'doc', id: 'introduction' },
        { type: 'doc', id: 'examples' },
        { type: 'doc', id: 'about' },
      ],
    });

    return { docs: items };
  }

  /**
   * Generate hierarchical navigation (UNIMARC)
   */
  private generateHierarchicalNavigation(
    config: SiteConfiguration,
  ): SidebarConfig {
    const items: SidebarItem[] = [
      {
        type: 'doc',
        id: 'index',
        label: `${config.namespace.toUpperCase()} Overview`,
      },
    ];

    // Add element sets with hierarchical grouping
    if (config.elementSets.length > 0) {
      const elementSetsSection: SidebarItem = {
        type: 'category',
        label: 'Element Sets',
        link: { type: 'doc', id: 'elements/index' },
        items: [],
      };

      // Group UNIMARC element sets by field ranges
      const fieldGroups = this.groupUnimarcElementSets(config.elementSets);

      for (const [groupName, elementSets] of Object.entries(fieldGroups)) {
        elementSetsSection.items!.push({
          type: 'category',
          label: groupName,
          items: elementSets.map((es) => ({
            type: 'doc' as const,
            id: `elements/${es.id}/index`,
          })),
        });
      }

      items.push(elementSetsSection);
    }

    // Add vocabularies with hierarchical grouping
    if (config.vocabularies.length > 0) {
      const vocabulariesSection: SidebarItem = {
        type: 'category',
        label: 'Vocabularies',
        link: { type: 'doc', id: 'vocabularies/index' },
        items: [],
      };

      // Group vocabularies by material type
      const categories = this.groupVocabulariesByCategory(config.vocabularies);

      for (const [category, vocabularies] of Object.entries(categories)) {
        vocabulariesSection.items!.push({
          type: 'category',
          label: this.formatCategoryName(category),
          items: vocabularies.map((v) => ({
            type: 'doc' as const,
            id: `vocabularies/${v.id}/index`,
          })),
        });
      }

      items.push(vocabulariesSection);
    }

    // Add search and tools section for complex sites
    items.push({
      type: 'category',
      label: 'Tools & Resources',
      items: [
        { type: 'doc', id: 'search' },
        { type: 'doc', id: 'cross-set-browser' },
        { type: 'doc', id: 'field-guide' },
      ],
    });

    // Add documentation section
    items.push({
      type: 'category',
      label: 'Documentation',
      items: [
        { type: 'doc', id: 'introduction' },
        { type: 'doc', id: 'examples' },
        { type: 'doc', id: 'about' },
      ],
    });

    return { docs: items };
  }

  /**
   * Group UNIMARC element sets by field ranges
   */
  private groupUnimarcElementSets(
    elementSets: ElementSet[],
  ): Record<string, ElementSet[]> {
    const groups: Record<string, ElementSet[]> = {
      'Control & Coded Fields': [],
      'Descriptive Fields': [],
      'Linking Fields': [],
      'Subject & Added Entry Fields': [],
      'Holdings & Location Fields': [],
      'Material-Specific Fields': [],
    };

    for (const elementSet of elementSets) {
      const id = elementSet.id.toLowerCase();

      if (id.includes('0xx') || id.includes('1xx')) {
        groups['Control & Coded Fields'].push(elementSet);
      } else if (id.includes('2xx') || id.includes('3xx')) {
        groups['Descriptive Fields'].push(elementSet);
      } else if (id.includes('4')) {
        groups['Linking Fields'].push(elementSet);
      } else if (
        id.includes('5xx') ||
        id.includes('6xx') ||
        id.includes('7xx')
      ) {
        groups['Subject & Added Entry Fields'].push(elementSet);
      } else if (id.includes('8')) {
        groups['Holdings & Location Fields'].push(elementSet);
      } else {
        groups['Material-Specific Fields'].push(elementSet);
      }
    }

    // Remove empty groups
    return Object.fromEntries(
      Object.entries(groups).filter(([_, items]) => items.length > 0),
    );
  }

  /**
   * Group vocabularies by category
   */
  private groupVocabulariesByCategory(
    vocabularies: Vocabulary[],
  ): Record<string, Vocabulary[]> {
    const categories: Record<string, Vocabulary[]> = {};

    for (const vocabulary of vocabularies) {
      const category = vocabulary.category || 'general';

      if (!categories[category]) {
        categories[category] = [];
      }
      categories[category].push(vocabulary);
    }

    return categories;
  }

  /**
   * Format category name for display
   */
  private formatCategoryName(category: string): string {
    const categoryMap: Record<string, string> = {
      cartographic: 'Cartographic Materials',
      'sound-recordings': 'Sound Recordings',
      graphics: 'Graphics',
      'visual-projections': 'Visual Projections',
      'electronic-resources': 'Electronic Resources',
      '3d-materials': 'Three-Dimensional Materials',
      'user-tasks': 'User Tasks',
      'content-form': 'Content Form',
      general: 'General',
    };

    return (
      categoryMap[category] ||
      category
        .split('-')
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ')
    );
  }

  /**
   * Generate TypeScript sidebar file content
   */
  private generateSidebarFile(config: SidebarConfig): string {
    return `import type { SidebarsConfig } from '@docusaurus/plugin-content-docs';

/**
 * Creating a sidebar enables you to:
 - create an ordered group of docs
 - render a sidebar for each doc of that group
 - provide next/previous navigation

 The sidebars can be generated from the filesystem, or explicitly defined here.

 Create as many sidebars as you want.
 */
const sidebars: SidebarsConfig = ${JSON.stringify(config, null, 2)};

export default sidebars;
`;
  }
}

/**
 * Main function
 */
async function main() {
  try {
    // Load site configurations
    const configsPath = path.join(
      __dirname,
      '../output/site-configurations/all-site-configs.json',
    );

    if (!fs.existsSync(configsPath)) {
      throw new Error(
        `Site configurations not found. Please run parse-ifla-report.ts first.`,
      );
    }

    const siteConfigs: Record<string, SiteConfiguration> = JSON.parse(
      fs.readFileSync(configsPath, 'utf-8'),
    );

    // Generate navigation
    const generator = new NavigationGenerator();
    await generator.generateAllNavigation(siteConfigs);
  } catch (error) {
    console.error('‚ùå Error generating navigation:', error);
    process.exit(1);
  }
}

// Export for testing
export { NavigationGenerator };

// Run if called directly
if (require.main === module) {
  main();
}
