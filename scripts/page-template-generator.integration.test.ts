import * as fs from 'fs';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { PageTemplateGenerator } from './page-template-generator';
import { SiteConfiguration } from './parse-ifla-report';
import { FileStructureValidator } from './utils/file-structure-validator';

// Mock fs module
vi.mock('fs', () => ({
  existsSync: vi.fn(),
  mkdirSync: vi.fn(),
  writeFileSync: vi.fn(),
  readFileSync: vi.fn(),
  promises: {
    access: vi.fn(),
    readdir: vi.fn(),
    mkdir: vi.fn(),
    writeFile: vi.fn(),
  },
}));

// Mock path module
vi.mock('path', () => {
  return {
    join: vi.fn((...args) => args.join('/')),
    dirname: vi.fn((p) => p.split('/').slice(0, -1).join('/')),
    basename: vi.fn((p) => p.split('/').pop()),
    default: {
      join: vi.fn((...args) => args.join('/')),
      dirname: vi.fn((p) => p.split('/').slice(0, -1).join('/')),
      basename: vi.fn((p) => p.split('/').pop()),
    },
  };
});

// Mock sidebar-reference-extractor
const mockExtractSidebarReferencesFromFile = vi.fn();
const mockExpandAutogeneratedReferences = vi.fn();
vi.mock('./utils/sidebar-reference-extractor', () => ({
  extractSidebarReferencesFromFile: mockExtractSidebarReferencesFromFile,
  expandAutogeneratedReferences: mockExpandAutogeneratedReferences,
}));

// Mock file-existence-checker
const mockCheckFilesExist = vi.fn();
const mockGenerateMissingFilesReport = vi.fn();
vi.mock('./utils/file-existence-checker', () => ({
  checkFilesExist: mockCheckFilesExist,
  generateMissingFilesReport: mockGenerateMissingFilesReport,
}));

describe('Page Template Generator Integration Tests', () => {
  // Sample test data
  const mockConfig: SiteConfiguration = {
    namespace: 'test-integration',
    title: 'Test Integration Standard',
    description: 'A test standard for integration testing',
    navigationStrategy: 'hierarchical',
    elementSets: [
      {
        id: 'element-set-1',
        title: 'Element Set 1',
        description: 'First element set',
        elementCount: 10,
        languages: ['en', 'fr'],
      },
      {
        id: 'element-set-2',
        title: 'Element Set 2',
        description: 'Second element set',
        elementCount: 15,
        languages: ['en'],
      },
    ],
    vocabularies: [
      {
        id: 'vocabulary-1',
        title: 'Vocabulary 1',
        description: 'First vocabulary',
        conceptCount: 20,
        languages: ['en', 'fr'],
      },
      {
        id: 'category/vocabulary-2',
        title: 'Vocabulary 2',
        description: 'Second vocabulary',
        conceptCount: 15,
        languages: ['en'],
        category: 'Test Category',
      },
    ],
    statistics: {
      totalElements: 25,
      totalConcepts: 35,
      elementSets: 2,
      vocabularies: 2,
    },
  };

  // Mock sidebar references
  const mockSidebarReferences = [
    { id: 'index', type: 'doc' },
    { id: 'introduction', type: 'doc' },
    { id: 'examples', type: 'doc' },
    { id: 'about', type: 'doc' },
    { id: 'elements', type: 'autogenerated', dirName: 'elements' },
    { id: 'vocabularies', type: 'autogenerated', dirName: 'vocabularies' },
    { id: 'search', type: 'doc' },
    { id: 'cross-set-browser', type: 'doc' },
  ];

  // Mock expanded references
  const mockExpandedReferences = [
    ...mockSidebarReferences,
    { id: 'elements/element-set-1', type: 'doc' },
    { id: 'elements/element-set-2', type: 'doc' },
    { id: 'vocabularies/vocabulary-1', type: 'doc' },
    { id: 'vocabularies/category/vocabulary-2', type: 'doc' },
  ];

  beforeEach(() => {
    // Reset mocks
    vi.resetAllMocks();

    // Default mock implementations
    (fs.existsSync as any).mockReturnValue(false); // Force file creation
    (fs.promises.access as any).mockResolvedValue(undefined); // Files exist by default
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Complete Generation Process', () => {
    it('should generate all required files and pass validation', async () => {
      // Setup
      const generator = new PageTemplateGenerator('standards');
      const validator = new FileStructureValidator('standards');

      // Mock sidebar reference extraction
      mockExtractSidebarReferencesFromFile.mockResolvedValue(mockSidebarReferences);
      mockExpandAutogeneratedReferences.mockResolvedValue(mockExpandedReferences);

      // Mock file existence checker to initially report missing files, then none after generation

      // First call (before generation) - report missing files
      const missingFiles = [
        {
          id: 'elements/element-set-1',
          expectedPath:
            'standards/test-integration/docs/elements/element-set-1/index.mdx',
          type: 'doc',
        },
        {
          id: 'vocabularies/vocabulary-1',
          expectedPath:
            'standards/test-integration/docs/vocabularies/vocabulary-1.mdx',
          type: 'doc',
        },
      ];
      mockCheckFilesExist.mockResolvedValueOnce(missingFiles);
      mockGenerateMissingFilesReport.mockReturnValueOnce('Found 2 missing files');

      // Second call (after generation) - report no missing files
      mockCheckFilesExist.mockResolvedValueOnce([]);
      mockGenerateMissingFilesReport.mockReturnValueOnce(
        'All sidebar references have corresponding files. ✅',
      );

      // Execute
      // Step 1: Generate site page templates
      await generator.generateSitePageTemplates('test-integration', mockConfig);

      // Step 2: Validate sidebar references (before fixing)
      const initialValidation =
        await validator.validateSidebarReferences('test-integration');

      // Step 3: Generate missing files
      await validator.generateMissingFiles(
        'test-integration',
        initialValidation.missingFiles,
      );

      // Step 4: Validate again (after fixing)
      const finalValidation =
        await validator.validateSidebarReferences('test-integration');

      // Verify
      // Check initial validation
      expect(initialValidation.isValid).toBe(false);
      expect(initialValidation.missingFiles).toEqual(missingFiles);
      expect(initialValidation.report).toBe('Found 2 missing files');

      // Check final validation
      expect(finalValidation.isValid).toBe(true);
      expect(finalValidation.missingFiles).toEqual([]);
      expect(finalValidation.report).toBe(
        'All sidebar references have corresponding files. ✅',
      );

      // Verify file generation
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        expect.stringContaining('elements/element-set-1/index.mdx'),
        expect.stringContaining('# Element Set 1'),
      );
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        expect.stringContaining('elements/element-set-2/index.mdx'),
        expect.stringContaining('# Element Set 2'),
      );
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        expect.stringContaining('vocabularies/vocabulary-1.mdx'),
        expect.stringContaining('# Vocabulary 1'),
      );
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        expect.stringContaining('vocabularies/category/vocabulary-2.mdx'),
        expect.stringContaining('# Vocabulary 2'),
      );
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        expect.stringContaining('introduction.mdx'),
        expect.stringContaining('# Test Integration Standard Introduction'),
      );
    });
  });

  describe('Validation Process', () => {
    it('should identify missing files and generate a report', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');

      // Mock sidebar reference extraction
      mockExtractSidebarReferencesFromFile.mockResolvedValue(mockSidebarReferences);
      mockExpandAutogeneratedReferences.mockResolvedValue(mockExpandedReferences);

      // Mock file existence checker to report missing files
      const missingFiles = [
        {
          id: 'elements/element-set-1',
          expectedPath:
            'standards/test-integration/docs/elements/element-set-1/index.mdx',
          type: 'doc',
        },
        {
          id: 'vocabularies/vocabulary-1',
          expectedPath:
            'standards/test-integration/docs/vocabularies/vocabulary-1.mdx',
          type: 'doc',
        },
      ];
      mockCheckFilesExist.mockResolvedValue(missingFiles);
      mockGenerateMissingFilesReport.mockReturnValue('Found 2 missing files');

      // Execute
      const validation =
        await validator.validateSidebarReferences('test-integration');

      // Verify
      expect(validation.isValid).toBe(false);
      expect(validation.missingFiles).toEqual(missingFiles);
      expect(validation.report).toBe('Found 2 missing files');
      expect(mockExtractSidebarReferencesFromFile).toHaveBeenCalledWith(
        'standards/test-integration/sidebars.ts',
      );
      expect(mockExpandAutogeneratedReferences).toHaveBeenCalledWith(
        'standards/test-integration',
        mockSidebarReferences,
      );
      expect(mockCheckFilesExist).toHaveBeenCalledWith(
        'standards/test-integration',
        mockExpandedReferences,
      );
      expect(mockGenerateMissingFilesReport).toHaveBeenCalledWith(missingFiles);
    });
  });

  describe('Missing File Generation', () => {
    it('should generate placeholder content for missing files', async () => {
      // Setup
      const validator = new FileStructureValidator('standards');

      // Mock fs.promises.access to fail (files don't exist)
      (fs.promises.access as any).mockRejectedValue(
        new Error('File not found'),
      );

      // Mock fs.promises.mkdir to succeed
      (fs.promises.mkdir as any).mockResolvedValue(undefined);

      // Mock fs.promises.writeFile to succeed
      (fs.promises.writeFile as any).mockResolvedValue(undefined);

      // Missing files to generate
      const missingFiles = [
        {
          id: 'elements/element-set-1',
          expectedPath:
            'standards/test-integration/docs/elements/element-set-1/index.mdx',
          type: 'doc' as const,
        },
        {
          id: 'vocabularies/vocabulary-1',
          expectedPath:
            'standards/test-integration/docs/vocabularies/vocabulary-1.mdx',
          type: 'doc' as const,
        },
      ];

      // Execute
      await validator.generateMissingFiles('test-integration', missingFiles);

      // Verify
      expect(fs.promises.mkdir).toHaveBeenCalledWith(
        'standards/test-integration/docs/elements/element-set-1/index.mdx',
        { recursive: true },
      );
      expect(fs.promises.mkdir).toHaveBeenCalledWith(
        'standards/test-integration/docs/vocabularies/vocabulary-1.mdx',
        { recursive: true },
      );

      expect(fs.promises.writeFile).toHaveBeenCalledWith(
        'standards/test-integration/docs/elements/element-set-1/index.mdx',
        expect.stringContaining('# Element-set-1'),
      );
      expect(fs.promises.writeFile).toHaveBeenCalledWith(
        'standards/test-integration/docs/vocabularies/vocabulary-1.mdx',
        expect.stringContaining('# Vocabulary-1'),
      );
    });
  });
});
