import type { SidebarsConfig } from '@docusaurus/plugin-content-docs';
import fs from 'fs/promises';
import path from 'path';

/**
 * Interface for document ID references extracted from sidebar
 */
export interface DocReference {
  id: string;
  type: 'doc' | 'autogenerated';
  dirName?: string;
}

/**
 * Extracts all document IDs from a sidebar configuration
 * @param sidebar The sidebar configuration object
 * @returns Array of document IDs referenced in the sidebar
 */
export async function extractSidebarReferences(
  sidebar: SidebarsConfig,
): Promise<DocReference[]> {
  const references: DocReference[] = [];

  // Process each sidebar section
  for (const [sidebarId, items] of Object.entries(sidebar)) {
    if (Array.isArray(items)) {
      await processItems(items, references);
    }
  }

  return references;
}

/**
 * Process sidebar items recursively to extract document IDs
 * @param items Array of sidebar items
 * @param references Array to collect document references
 */
async function processItems(
  items: any[],
  references: DocReference[],
): Promise<void> {
  for (const item of items) {
    if (item.type === 'doc') {
      // Direct document reference
      references.push({
        id: item.id,
        type: 'doc',
      });
    } else if (item.type === 'category') {
      // Category with link
      if (item.link?.type === 'doc') {
        references.push({
          id: item.link.id,
          type: 'doc',
        });
      }

      // Process nested items
      if (Array.isArray(item.items)) {
        await processItems(item.items, references);
      }
    } else if (item.type === 'autogenerated') {
      // Autogenerated directory
      references.push({
        id: item.dirName,
        type: 'autogenerated',
        dirName: item.dirName,
      });

      // For autogenerated directories, we need to find all files in that directory
      // This will be handled separately in the file existence checker
    }
  }
}

/**
 * Expands autogenerated directory references to include all files in those directories
 * @param siteDir The site directory path
 * @param references Array of document references
 * @returns Expanded array of document references
 */
export async function expandAutogeneratedReferences(
  siteDir: string,
  references: DocReference[],
): Promise<DocReference[]> {
  const expanded: DocReference[] = [...references];

  for (const ref of references) {
    if (ref.type === 'autogenerated' && ref.dirName) {
      const dirPath = path.join(siteDir, 'docs', ref.dirName);

      try {
        // Get all files in the directory
        const files = await fs.readdir(dirPath, { withFileTypes: true });

        // Process each file
        for (const file of files) {
          if (
            file.isFile() &&
            (file.name.endsWith('.md') || file.name.endsWith('.mdx'))
          ) {
            // Add as a document reference
            const fileName = file.name.replace(/\.(md|mdx)$/, '');
            const docId = path.join(ref.dirName, fileName);

            // Skip index files as they're usually already covered by the category link
            if (fileName !== 'index') {
              expanded.push({
                id: docId,
                type: 'doc',
              });
            }
          } else if (file.isDirectory()) {
            // Handle nested directories recursively
            const nestedDirName = path.join(ref.dirName, file.name);
            expanded.push({
              id: nestedDirName,
              type: 'autogenerated',
              dirName: nestedDirName,
            });

            // Recursively expand this directory
            const nestedRefs = await expandAutogeneratedReferences(siteDir, [
              {
                id: nestedDirName,
                type: 'autogenerated',
                dirName: nestedDirName,
              },
            ]);

            // Add all nested references
            expanded.push(...nestedRefs.slice(1)); // Skip the first one as it's already added
          }
        }
      } catch (error) {
        console.error(
          `Error processing autogenerated directory ${ref.dirName}:`,
          error,
        );
      }
    }
  }

  return expanded;
}

/**
 * Extracts all document IDs from a sidebar configuration file
 * @param sidebarPath Path to the sidebar configuration file
 * @returns Array of document IDs referenced in the sidebar
 */
export async function extractSidebarReferencesFromFile(
  sidebarPath: string,
): Promise<DocReference[]> {
  try {
    // Import the sidebar configuration
    const sidebar = require(sidebarPath).default;
    return await extractSidebarReferences(sidebar);
  } catch (error) {
    console.error(
      `Error extracting sidebar references from ${sidebarPath}:`,
      error,
    );
    return [];
  }
}
