import { describe, expect, it, vi } from 'vitest';
import * as fs from 'fs/promises';
import * as fileExistenceChecker from './utils/file-existence-checker';
import { FileStructureValidator } from './utils/file-structure-validator';
import * as sidebarReferenceExtractor from './utils/sidebar-reference-extractor';

// Mock the utility modules
vi.mock('./utils/sidebar-reference-extractor', () => ({
  extractSidebarReferencesFromFile: vi.fn(),
  expandAutogeneratedReferences: vi.fn(),
}));

vi.mock('./utils/file-existence-checker', () => ({
  checkFilesExist: vi.fn(),
  generateMissingFilesReport: vi.fn(),
}));

// Mock fs/promises
vi.mock('fs/promises', () => {
  const mockAccess = vi.fn();
  const mockReaddir = vi.fn();
  const mockMkdir = vi.fn();
  const mockWriteFile = vi.fn();
  
  return {
    default: {
      access: mockAccess,
      readdir: mockReaddir,
      mkdir: mockMkdir,
      writeFile: mockWriteFile,
    },
    access: mockAccess,
    readdir: mockReaddir,
    mkdir: mockMkdir,
    writeFile: mockWriteFile,
  };
});

describe('Sidebar References Validation Integration', () => {
  it('should validate sidebar references and identify missing files', async () => {
    // Setup
    const validator = new FileStructureValidator('standards');
    const namespace = 'test-standard';

    // Mock the fs/promises.access function to succeed
    vi.mocked(fs.access).mockResolvedValue(undefined);

    // Mock the sidebar reference extraction
    const mockReferences = [
      { id: 'index', type: 'doc' },
      { id: 'introduction', type: 'doc' },
      { id: 'elements/element-set-1', type: 'doc' },
      { id: 'vocabularies/vocabulary-1', type: 'doc' },
    ];
    vi.mocked(sidebarReferenceExtractor.extractSidebarReferencesFromFile).mockResolvedValue(
      mockReferences as any,
    );
    vi.mocked(sidebarReferenceExtractor.expandAutogeneratedReferences).mockResolvedValue(
      mockReferences as any,
    );

    // Mock the file existence checker to report missing files
    const missingFiles = [
      {
        id: 'elements/element-set-1',
        expectedPath:
          'standards/test-standard/docs/elements/element-set-1/index.mdx',
        type: 'doc',
      },
      {
        id: 'vocabularies/vocabulary-1',
        expectedPath:
          'standards/test-standard/docs/vocabularies/vocabulary-1.mdx',
        type: 'doc',
      },
    ];
    vi.mocked(fileExistenceChecker.checkFilesExist).mockResolvedValue(missingFiles as any);
    vi.mocked(fileExistenceChecker.generateMissingFilesReport).mockReturnValue(
      'Found 2 missing files',
    );

    // Execute
    const result = await validator.validateSidebarReferences(namespace);

    // Verify
    expect(result.isValid).toBe(false);
    expect(result.missingFiles).toEqual(missingFiles);
    expect(result.report).toBe('Found 2 missing files');

    // Verify function calls
    expect(fs.access).toHaveBeenCalledWith(
      'standards/test-standard/sidebars.ts',
    );
    expect(
      sidebarReferenceExtractor.extractSidebarReferencesFromFile,
    ).toHaveBeenCalledWith('standards/test-standard/sidebars.ts');
    expect(
      sidebarReferenceExtractor.expandAutogeneratedReferences,
    ).toHaveBeenCalledWith('standards/test-standard', mockReferences);
    expect(fileExistenceChecker.checkFilesExist).toHaveBeenCalledWith(
      'standards/test-standard',
      mockReferences,
    );
    expect(
      fileExistenceChecker.generateMissingFilesReport,
    ).toHaveBeenCalledWith(missingFiles);
  });

  it('should generate missing files when needed', async () => {
    // Setup
    const validator = new FileStructureValidator('standards');
    const namespace = 'test-standard';

    // Mock the fs/promises functions
    vi.mocked(fs.access).mockRejectedValue(new Error('File not found')); // File doesn't exist
    vi.mocked(fs.mkdir).mockResolvedValue(undefined);
    vi.mocked(fs.writeFile).mockResolvedValue(undefined);

    // Missing files to generate
    const missingFiles = [
      {
        id: 'elements/element-set-1',
        expectedPath:
          'standards/test-standard/docs/elements/element-set-1/index.mdx',
        type: 'doc',
      },
      {
        id: 'vocabularies/vocabulary-1',
        expectedPath:
          'standards/test-standard/docs/vocabularies/vocabulary-1.mdx',
        type: 'doc',
      },
    ];

    // Execute
    await validator.generateMissingFiles(namespace, missingFiles);

    // Verify - mkdir is called with the directory path, not the file path
    expect(fs.mkdir).toHaveBeenCalledWith(
      'standards/test-standard/docs/elements/element-set-1',
      { recursive: true },
    );
    expect(fs.mkdir).toHaveBeenCalledWith(
      'standards/test-standard/docs/vocabularies',
      { recursive: true },
    );

    expect(fs.writeFile).toHaveBeenCalledWith(
      'standards/test-standard/docs/elements/element-set-1/index.mdx',
      expect.stringContaining('# Element Set 1'),
    );
    expect(fs.writeFile).toHaveBeenCalledWith(
      'standards/test-standard/docs/vocabularies/vocabulary-1.mdx',
      expect.stringContaining('# Vocabulary 1'),
    );
  });

  it('should validate all sites in the standards directory', async () => {
    // Setup
    const validator = new FileStructureValidator('standards');

    // Mock fs.readdir to return site directories
    vi.mocked(fs.readdir).mockResolvedValue([
      { name: 'site1', isDirectory: () => true },
      { name: 'site2', isDirectory: () => true },
      { name: 'file.txt', isDirectory: () => false }, // Should be ignored
    ] as any);

    // Mock validateSidebarReferences to return results
    const validateSpy = vi
      .spyOn(validator, 'validateSidebarReferences')
      .mockResolvedValueOnce({
        isValid: true,
        missingFiles: [],
        report: 'All sidebar references have corresponding files. ✅',
      })
      .mockResolvedValueOnce({
        isValid: false,
        missingFiles: [
          {
            id: 'doc1',
            expectedPath: 'standards/site2/docs/doc1.mdx',
            type: 'doc',
          },
        ],
        report: 'Found 1 missing files referenced in sidebar',
      });

    // Execute
    const results = await validator.validateAllSites();

    // Verify
    expect(fs.readdir).toHaveBeenCalledWith('standards', {
      withFileTypes: true,
    });
    expect(validateSpy).toHaveBeenCalledTimes(2);
    expect(validateSpy).toHaveBeenCalledWith('site1');
    expect(validateSpy).toHaveBeenCalledWith('site2');

    expect(results).toEqual({
      site1: {
        isValid: true,
        missingFiles: [],
        report: 'All sidebar references have corresponding files. ✅',
      },
      site2: {
        isValid: false,
        missingFiles: [
          {
            id: 'doc1',
            expectedPath: 'standards/site2/docs/doc1.mdx',
            type: 'doc',
          },
        ],
        report: 'Found 1 missing files referenced in sidebar',
      },
    });

    // Restore the spy
    validateSpy.mockRestore();
  });
});
