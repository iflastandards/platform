import path from 'path';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import * as fileChecker from './utils/file-existence-checker';
import * as sidebarExtractor from './utils/sidebar-reference-extractor';

// Mock the modules
vi.mock('./utils/sidebar-reference-extractor', () => ({
  extractSidebarReferencesFromFile: vi.fn(),
  expandAutogeneratedReferences: vi.fn(),
}));

vi.mock('./utils/file-existence-checker', () => ({
  checkFilesExist: vi.fn(),
  generateMissingFilesReport: vi.fn(),
}));

// Mock console.log and console.error
vi.spyOn(console, 'log').mockImplementation(() => {});
vi.spyOn(console, 'error').mockImplementation(() => {});

// Mock process.exit
const mockExit = vi.spyOn(process, 'exit').mockImplementation((code) => {
  throw new Error(`Process exit with code ${code}`);
});

describe('Validate Sidebar References Script', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Reset process.argv
    process.argv = ['node', 'validate-sidebar-references.ts'];
  });

  it('should validate sidebar references and exit with code 0 when no files are missing', async () => {
    // Mock the functions
    (
      sidebarExtractor.extractSidebarReferencesFromFile as any
    ).mockResolvedValue([{ id: 'index', type: 'doc' }]);

    (sidebarExtractor.expandAutogeneratedReferences as any).mockResolvedValue([
      { id: 'index', type: 'doc' },
    ]);

    (fileChecker.checkFilesExist as any).mockResolvedValue([]);

    (fileChecker.generateMissingFilesReport as any).mockReturnValue(
      'All files exist',
    );

    // Set up command line arguments
    process.argv.push('standards/isbd');

    // Import the script (this will run the main function)
    try {
      await import('./validate-sidebar-references');
    } catch (error) {
      // This should not throw an error
      expect(error).toBeUndefined();
    }

    // Verify the functions were called with the correct arguments
    expect(
      sidebarExtractor.extractSidebarReferencesFromFile,
    ).toHaveBeenCalledWith(
      path.join(path.resolve('standards/isbd'), 'sidebars.ts'),
    );

    expect(sidebarExtractor.expandAutogeneratedReferences).toHaveBeenCalled();
    expect(fileChecker.checkFilesExist).toHaveBeenCalled();
    expect(fileChecker.generateMissingFilesReport).toHaveBeenCalled();

    // Verify process.exit was not called
    expect(mockExit).not.toHaveBeenCalled();
  });

  it('should exit with code 1 when files are missing', async () => {
    // Mock the functions
    (
      sidebarExtractor.extractSidebarReferencesFromFile as any
    ).mockResolvedValue([{ id: 'index', type: 'doc' }]);

    (sidebarExtractor.expandAutogeneratedReferences as any).mockResolvedValue([
      { id: 'index', type: 'doc' },
    ]);

    (fileChecker.checkFilesExist as any).mockResolvedValue([
      { id: 'index', expectedPath: '/site/docs/index.mdx', type: 'doc' },
    ]);

    (fileChecker.generateMissingFilesReport as any).mockReturnValue(
      'Missing files',
    );

    // Set up command line arguments
    process.argv.push('standards/isbd');

    // Import the script (this will run the main function)
    try {
      await import('./validate-sidebar-references');
      // This should throw an error
      expect(true).toBe(false);
    } catch (error) {
      expect(error.message).toContain('Process exit with code 1');
    }

    // Verify the functions were called
    expect(
      sidebarExtractor.extractSidebarReferencesFromFile,
    ).toHaveBeenCalled();
    expect(sidebarExtractor.expandAutogeneratedReferences).toHaveBeenCalled();
    expect(fileChecker.checkFilesExist).toHaveBeenCalled();
    expect(fileChecker.generateMissingFilesReport).toHaveBeenCalled();

    // Verify process.exit was called with code 1
    expect(mockExit).toHaveBeenCalledWith(1);
  });

  it('should exit with code 1 when no site directory is provided', async () => {
    // Import the script (this will run the main function)
    try {
      await import('./validate-sidebar-references');
      // This should throw an error
      expect(true).toBe(false);
    } catch (error) {
      expect(error.message).toContain('Process exit with code 1');
    }

    // Verify console.error was called with usage message
    expect(console.error).toHaveBeenCalledWith(
      expect.stringContaining('Usage: validate-sidebar-references'),
    );

    // Verify process.exit was called with code 1
    expect(mockExit).toHaveBeenCalledWith(1);
  });
});
